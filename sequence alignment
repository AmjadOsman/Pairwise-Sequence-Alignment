import os,sys
from collections import defaultdict
from typing import Sequence # used for extractmatrix


codon_chart={'phe':['UUU','UUC'],#Pheylalanine
'leu':['UUA','UUG','CUU','CUC','CUA','CUG' ],#Leucine
'lle':['AUU','AUC','AUA'],#Isoleucine
'met':['AUG'],#Methionine - start codon
'val':['GUU','GUC','GUA','GUG'],#valine
'ser':['UCU','UCC','UCA','UCG','AGU','AGC'],#serine
'pro':['CCU','CCC','CCA','CCG'],#proline
'thr':['ACU','ACC','ACA','ACG'],#threonine 
'ala':['GCU','GCC','GCA','GCG'],#Alanine
'tyr':['UAU','UAC'],#Tyrosine
'stop':['UAA','UAG','UGA'],#Stop codon
'his':['CAU','CAC',],#Histidine
'gln':['CAA','CAG'],#Glutamine
'asn':['AAU','AAC'],#Asparagine
'lys':['AAA','AAG'],#Lysine
'asp':['GAU','GAC'],#Aspartic acid
'glu':['GAU','GAC'],#glutamic acid
'cys':['UGU','UGC'],#cysteine
'arg':['CGU','CGC','CGA','CGG','AGA','AGG'],#arginine 
'gly':['GGU','GGC','GGA','GGA']}#glycine
    
def transcription(sequence): # converting Dna to rna 
    rna_seq=sequence.replace('T','U')
    return rna_seq

def translation(rna_strand): # converting rna to protein 
    rna_strand=[rna_strand[i:i+3] for i in range(0,len(rna_strand),3)] 
    protein_seq=''
    for protein in rna_strand:
        for key, value in codon_chart.items():
            if protein in value:# ask if you want to comma between protein
                protein_seq += key #not sure if later need value or key , but we can switch it 
    return protein_seq

def get_file(): # getting and opening file 
    inp1=input('Enter filename for first sequence:')
    try:
        with open(inp1,'r') as f:
            pass
    except FileNotFoundError:
        print('.txt not valid')
        exit()
    
    inp2=input('Enter filename for second sequence:')
    try:
        with open(inp2,'r') as f:
            pass
    except FileNotFoundError:
        print('.txt not valid')
        exit()
    
    # sub_matrix=input('Enter Filename for matrix:')
    # try:
    #     with open (sub_matrix,'r') as f:
    #         pass
    # except FileNotFoundError:
    #     print('Invalid file')
    #     exit()

    return inp1,inp2



# extracting the sequence 
def extract_seq(file):
    with open(file) as A:
        line= A.readlines()
        lines=line[1].strip()
    return lines 


#making a zero filled matrix based on sequence size 
def matrix(x,y):
    return [[0]*y for i in range(x)]


# extracts the matrix and saves it in a dictionary
def extractmatrix(file):
    matrix=defaultdict(dict)

    with open (file,'r') as f: 
        line= f.readlines()
        nucleotide= line[1].strip().split(',')
        lines=[j.strip().split(',') for j in line] # you took out the [] out of the j 
        lines=lines[2:]
        lines=[[int((x))for x in lst]for lst in lines]

        for dna in nucleotide:
            # print(f'this is dna {dna}')
            for number in lines:

                matrix[dna]=number
                lines.remove(number)
                break
            
        return matrix
                     

def matrix_score (file):
    with open (file,'r') as f:
        matrix= f.readlines()
        line=[i.strip().split(',') for i in matrix ]
        lines= line[2:]
        lines=[[int((x))for x in i ]for i in lines]
        firstlst= range(len(lines[0]))
        # print(f'ths is firstlst {firstlst}')
    
            
        print ([lines[i][i]for i in firstlst])


    
match_score = 1 
mismatch_score=-1

def global_alignment(x,y,gap):
    n_matrix=matrix(len(x)+1,len(y)+1) 
    main_matrix= matrix(len(x)+1,len(y)+1)
    
    for i in range(len(x)): # match mismatch matrix 
        for j in range(len(y)):
            if x[i]==y[j]:
                n_matrix[i][j]=match_score 
            else:
                n_matrix[i][j]=mismatch_score         
    # print( f'nmatrix-{n_matrix}')

    for i in range(len(x)+1): #gap score matrix 
        main_matrix[i][0]=gap*i
    for j in range(len(y)+1):
        main_matrix[0][j]=gap*j
    # print(f'main-{main_matrix}')

    for i in range(1,len(x)+1): # combining main and n matrix + getting the max value 
        for j in range(1,len(y)+1):
            main_matrix[i][j]=max(main_matrix[i-1][j-1]+n_matrix[i-1][j-1],max(main_matrix[i-1][j]+gap,main_matrix[i][j-1]+gap))
    print(f'Final matrix-{main_matrix}')


    #traceback

    align1= ''
    align2=''
    tracei=len(x)
    tracej=len(y)

    while (tracei>0 or tracej>0):
        if (tracei>0 and tracej>0 and main_matrix[tracei][tracej]==main_matrix[tracei-1][tracej-1]+n_matrix[tracei-1][tracej-1]):#diagonal 
        
            align1=x[tracei-1] +align1
            align2= y[tracej-1] + align2
            
            tracei=tracej-1
            tracej=tracej-1
        elif (tracei>0 and main_matrix[tracei][tracej]==main_matrix[tracei-1][tracej]+gap):#up 
            align1= x[tracei-1] +align1
            align2='-'+align2

            tracei=tracei-1
        else: # left
            align1='-'+align1
            align2=y[tracej-1] + align2

            tracej=tracej-1
    print(align2)
    print(align1)




def local_alignment(x,y,gap):

    l_matrix=matrix(len(x)+1,len(y)+1)
    # print(l_matrix)
    final_matrix= matrix(len(x)+1,len(y)+1)
    trace_matrix= matrix(len(x)+1,len(y)+1)

    for i in range(len(x)):
        for j in range(len(y)): 
            if x[i]==y[j]:
                l_matrix[i][j]=match_score
            else:
                l_matrix[i][j]=mismatch_score
    
    # print(f'this is l_matrix {l_matrix}')


    for i in range(len(x)+1):
            final_matrix[i][0]=i*gap
    for j in range(len(y)+1):
        final_matrix[0][j]=j*gap
    

    for inside,outside in enumerate(final_matrix): # l_matrix= [[0 if l <0 for l in a] for a in l_matrix] 
        for inner,outer in enumerate(outside):
            if outer<0:
                final_matrix[inside][inner]=0
    

    for i in range(1,len(x)+1):
        for j in range(1,len(y)+1):
            diagonal= final_matrix[i-1][j-1]+l_matrix[i-1][j-1]
            left=final_matrix[i][j-1]+gap
            up=final_matrix[i-1][j]+gap
            final_matrix[i][j]=max(0,diagonal,left,up)
            if final_matrix[i][j]==0:
                trace_matrix[i][j]=0 #0= end of path 
            if final_matrix[i][j]==up:
                trace_matrix[i][j]=1 # trace left
            if final_matrix[i][j]==left:
                trace_matrix[i][j]=2 #trace up
            if final_matrix[i][j]==diagonal: 
                trace_matrix[i][j]=3 # trace diagonal
    print(f'Final matrix-{final_matrix}')

    align1= ''
    align2=''
    tracei=len(x)
    tracej=len(y)

    while trace_matrix[tracei][tracej] !=0: 
        if trace_matrix[tracei][tracej]==3: 
            align1=x[tracei-1]+align1
            align2=y[tracej-1]+align2

            tracei=tracei-1 
            tracej=tracej-1 
        elif trace_matrix[tracei][tracej] == 2:
            align1='_'+align1
            align2=y[tracej-1]+align2
            tracej=tracej-1 
        elif trace_matrix[tracei][tracej]==1:
            align1=x[tracei-1]+align1
            align2='_'+ align2

            tracei=tracei-1

    print(align1)
    print(align2)



if __name__ == "__main__":
    protein1=''
    protein2= ''
    input1=input('nucleotide or peptide sequence? (answer n or p) ') 
    sequence1,sequence2=get_file()
    seq1=extract_seq(sequence1)
    seq2=extract_seq(sequence2)
    
    alignType = input("Which alignment would you like to use? Global,or local? (g,l) ")
    gap=int(input('Enter gap penalty'))
    if input1.lower()=='n':
        rna1=transcription(seq1)
        rna2=transcription(seq2)
        protein1=translation(rna1)
        protein2=translation(rna2)
        if alignType.lower()=='g':
            global_alignment(protein1,protein2,gap)
        elif alignType.lower()=='l':
            local_alignment(protein1,protein2,gap)
        else: 
            raise ValueError('Invalid nput')
            exit()
    else:
        if alignType.lower()=='g':
            global_alignment(seq1,seq2,gap)
        elif alignType.lower()=='l':
            local_alignment(seq1,seq2,gap)
        else: 
            raise ValueError('Invalid nput')
            
        

