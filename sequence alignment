import os,sys
from collections import defaultdict # used for extractmatrix
#ANFNNASWF
file_info=input('enter file') # line 3/4 is to open and read file 
file=open(file_info,'r')


file_seq=list(file.read()) # turning the sequence to list, allows me to transcribe
file_seq.remove('\n') # remove space 
print(file_seq)

codon_chart={'phe':['UUU','UUC'],#Pheylalanine
'leu':['UUA','UUG','CUU','CUC','CUA','CUG' ],#Leucine
'lle':['AUU','AUC','AUA'],#Isoleucine
'met':['AUG'],#Methionine - start codon
'val':['GUU','GUC','GUA','GUG'],#valine
'ser':['UCU','UCC','UCA','UCG','AGU','AGC'],#serine
'pro':['CCU','CCC','CCA','CCG'],#proline
'thr':['ACU','ACC','ACA','ACG'],#threonine 
'ala':['GCU','GCC','GCA','GCG'],#Alanine
'tyr':['UAU','UAC'],#Tyrosine
'stop':['UAA','UAG','UGA'],#Stop codon
'his':['CAU','CAC',],#Histidine
'gln':['CAA','CAG'],#Glutamine
'asn':['AAU','AAC'],#Asparagine
'lys':['AAA','AAG'],#Lysine
'asp':['GAU','GAC'],#Aspartic acid
'glu':['GAU','GAC'],#glutamic acid
'cys':['UGU','UGC'],#cysteine
'arg':['CGU','CGC','CGA','CGG','AGA','AGG'],#arginine 
'gly':['GGU','GGC','GGA','GGA']}#glycine
    
def transcription(sequence): # converting Dna to rna 
    rna_seq=sequence.replace('T','U')
    return rna_seq

def translation(rna_strand): # converting rna to protein 
    rna_strand=[rna_strand[i:i+3] for i in range(0,len(rna_strand),3)] 
    protein_seq=''
    for protein in rna_strand:
        for key, value in codon_chart.items():
            if protein in value:# ask if you want to comma between protein
                protein_seq += key #not sure if later need value or key , but we can switch it 
    return protein_seq

def get_file(): # getting and opening file 
    inp1=input('Enter file for first seq  ')
    try:
        with open(inp1,'r') as f:
            pass
    except FileNotFoundError:
        print('.txt not valid')
        exit()
    
    inp2=input('Enter Filename for second sequence:')
    try:
        with open(inp2,'r') as f:
            pass
    except FileNotFoundError:
        print('.txt not valid')
        exit()
    
    sub_matrix=input('Enter Filename for matrix:'):
    try:
        with open (sub_matrix,'r') as f:
            pass
    except FileNotFoundError:
        print('Invalid file')
        exit()

    return inp1,inp2,sub_matrix



# extracting the sequence 
def extract_seq(file):
    with open(file) as A:
        line= A.readlines()
        lines=line[1].strip()
    return lines 


#making a zero filled matrix based on sequence size 
def matrix(x,y):
    return [[0]*y for i in range(x)]


# extracts the matrix and saves it in a dictionary
def extractmatrix(file):
    matrix=defaultdict(dict)

    with open (file,'r') as f: 
        line= f.readlines()
        nucleotide= line[1].strip().split(',')
        lines=[j.strip().split(',') for j in line] # you took out the [] out of the j 
        lines=lines[2:]
        lines=[[int((x))for x in lst]for lst in lines]

        for dna in nucleotide:
            # print(f'this is dna {dna}')
            for number in lines:

                matrix[dna]=number
                lines.remove(number)
                break
            
        return matrix
                     

def matrix_score (file):
    with open (file,'r') as f:
        matrix= f.readlines()
        line=[i.strip().split(',') for i in matrix ]
        lines= line[2:]
        lines=[[int((x))for x in i ]for i in lines]
        firstlst= range(len(lines[0]))
        # print(f'ths is firstlst {firstlst}')
    
            
        print ([lines[i][i]for i in firstlst])
        
        
match_score = 1 
mismatch_score=-1
gap_score=-2



def global_alignment(x,y):


    n_matrix=matrix(len(x)+1,len(y)+1) # add +1 here 
    main_matrix= matrix(len(x)+1,len(y)+1)
   
    # trace_back=matrix(len(x)+1,len(y)+1)
    # trace_back[0][0]=(0,0)

    for i in range(len(x)): # match mismatch matrix 
        for j in range(len(y)):
            if x[i]==y[j]:
                n_matrix[i][j]=match_score

                
            else:
                n_matrix[i][j]=mismatch_score

                
    print( f'nmatrix-{n_matrix}')


    for i in range(len(x)+1):
        main_matrix[i][0]=gap_score*i
    for j in range(len(y)+1):
        main_matrix[0][j]=gap_score*j
    print(f'main-{main_matrix}')





    for i in range(1,len(x)+1):
        for j in range(1,len(y)+1):
            main_matrix[i][j]=max(main_matrix[i-1][j-1]+n_matrix[i-1][j-1],max(main_matrix[i-1][j]+gap_score,main_matrix[i][j-1]+gap_score))
    print(f'final-{main_matrix}')



    #traceback

    align1= ''
    align2=''
    tracei=len(x)
    tracej=len(y)

    while (tracei>0 or tracej>0):
        if (tracei>0 and tracej>0 and main_matrix[tracei][tracej]==main_matrix[tracei-1][tracej-1]+n_matrix[tracei-1][tracej-1]):
        
            align1=x[tracei-1] +align1
            align2= y[tracej-1] + align2
            
            tracei=tracej-1
            tracej=tracej-1
        elif (tracei>0 and main_matrix[tracei][tracej]==main_matrix[tracei-1][tracej]+gap_score):
            align1= x[tracei-1] +align1
            align2='-'+align2

            tracei=tracei-1
        else:
            align1='-'+align1
            align2=y[tracej-1] + align2

            tracej=tracej-1
    print(align2)
    print(align1)


def local_alignment(x,y):

    l_matrix=matrix(len(x)+1,len(y)+1)
    # print(l_matrix)
    final_matrix= matrix(len(x)+1,len(y)+1)
    trace_matrix= matrix(len(x)+1,len(y)+1)

    for i in range(len(x)):
        for j in range(len(y)): 
            if x[i]==y[j]:
                l_matrix[i][j]=match_score
            else:
                l_matrix[i][j]=mismatch_score
    

    
    print(f'this is l_matrix {l_matrix}')


    for i in range(len(x)+1):
            final_matrix[i][0]=i*gap_score
    for j in range(len(y)+1):
        final_matrix[0][j]=j*gap_score
    

    for inside,outside in enumerate(final_matrix): # l_matrix= [[0 if l <0 for l in a] for a in l_matrix] 
        for inner,outer in enumerate(outside):
            if outer<0:
                final_matrix[inside][inner]=0
    
    print(f'this is final{final_matrix}')

    for i in range(1,len(x)+1):
        for j in range(1,len(y)+1):
            diagonal= final_matrix[i-1][j-1]+l_matrix[i-1][j-1]
            left=final_matrix[i][j-1]+gap_score
            up=final_matrix[i-1][j]+gap_score
            final_matrix[i][j]=max(0,diagonal,left,up)
            if final_matrix[i][j]==0:
                trace_matrix[i][j]=0 #0= end of path 
            if final_matrix[i][j]==up:
                trace_matrix[i][j]=1 # trace left
            if final_matrix[i][j]==left:
                trace_matrix[i][j]=2 #trace up
            if final_matrix[i][j]==diagonal: 
                trace_matrix[i][j]=3 # trace diagonal
    

    align1= ''
    align2=''
    tracei=len(x)
    tracej=len(y)

    while trace_matrix[tracei][tracej] !=0: 
        if trace_matrix[tracei][tracej]==3: 
            align1=x[tracei-1]+align1
            align2=y[tracej-1]+align2

            tracei=tracei-1 
            tracej=tracej-1 
        elif trace_matrix[tracei][tracej] == 2:
            align1='_'+align1
            align2=y[tracej-1]+align2
            tracej=tracej-1 
        elif trace_matrix[tracei][tracej]==1:
            align1=x[tracei-1]+align1
            align2='_'+ align2

            tracei=tracei-1

    print(align1)
    print(align2)
       




             
    
  







    

